<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Promise规范及应用 | Micheal Yang的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="PromiseA+规范讲解PromiseA+规范前, 咱们先来了解一下这些术语, 以便在后续提到的时候有明确且统一的概念. 术语 promise 是一个有then方法的对象或者是函数，行为遵循本规范 thenable 是一个有then方法的对象或者是函数 value 是promise状态成功时的值，也就是resolve的参数, 包括各种数据类型, 也包括undefined&#x2F;thenable或者是">
<meta property="og:type" content="article">
<meta property="og:title" content="Promise规范及应用">
<meta property="og:url" content="http://example.com/2021/04/15/Promise%E8%A7%84%E8%8C%83%E5%8F%8A%E5%BA%94%E7%94%A8/index.html">
<meta property="og:site_name" content="Micheal Yang的博客">
<meta property="og:description" content="PromiseA+规范讲解PromiseA+规范前, 咱们先来了解一下这些术语, 以便在后续提到的时候有明确且统一的概念. 术语 promise 是一个有then方法的对象或者是函数，行为遵循本规范 thenable 是一个有then方法的对象或者是函数 value 是promise状态成功时的值，也就是resolve的参数, 包括各种数据类型, 也包括undefined&#x2F;thenable或者是">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-15T15:12:27.000Z">
<meta property="article:modified_time" content="2021-04-15T15:14:13.258Z">
<meta property="article:author" content="Micheal Yang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Micheal Yang的博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Micheal Yang的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Promise规范及应用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/15/Promise%E8%A7%84%E8%8C%83%E5%8F%8A%E5%BA%94%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2021-04-15T15:12:27.000Z" itemprop="datePublished">2021-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Promise规范及应用
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="PromiseA-规范"><a href="#PromiseA-规范" class="headerlink" title="PromiseA+规范"></a>PromiseA+规范</h1><p>讲解PromiseA+规范前, 咱们先来了解一下这些术语, 以便在后续提到的时候有明确且统一的概念.</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ol>
<li>promise 是一个有then方法的对象或者是函数，行为遵循本规范</li>
<li>thenable 是一个有then方法的对象或者是函数</li>
<li>value 是promise状态成功时的值，也就是resolve的参数, 包括各种数据类型, 也包括undefined/thenable或者是 promise</li>
<li>reason 是promise状态失败时的值, 也就是reject的参数, 表示拒绝的原因</li>
<li>exception 是一个使用throw抛出的异常值</li>
</ol>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>接下来分几部分来讲解PromiseA+规范. </p>
<h3 id="Promise-States"><a href="#Promise-States" class="headerlink" title="Promise States"></a>Promise States</h3><p>promise应该有三种状态. 要注意他们之间的流转关系.</p>
<ol>
<li><p>pending</p>
<p> 1.1 初始的状态, 可改变.<br> 1.2 一个promise在resolve或者reject前都处于这个状态。<br> 1.3 可以通过 resolve -&gt; fulfilled 状态;<br> 1.4 可以通过 reject -&gt; rejected 状态;</p>
</li>
<li><p>fulfilled</p>
<p> 2.1 最终态, 不可变.<br> 2.2 一个promise被resolve后会变成这个状态.<br> 2.3 必须拥有一个value值</p>
</li>
<li><p>rejected</p>
<p> 3.1 最终态, 不可变.<br> 3.2 一个promise被reject后会变成这个状态<br> 3.3 必须拥有一个reason</p>
</li>
</ol>
<p>Tips: 总结一下, 就是promise的状态流转是这样的</p>
<p>pending -&gt; resolve(value) -&gt; fulfilled<br>pending -&gt; reject(reason) -&gt; rejected</p>
<p>看一下图, 可能会更清晰一点, <a target="_blank" rel="noopener" href="https://www.processon.com/diagraming/606569d1e401fd13004977d2">https://www.processon.com/diagraming/606569d1e401fd13004977d2</a></p>
<h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><p>promise应该提供一个then方法, 用来访问最终的结果, 无论是value还是reason.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>参数要求</p>
<p> 1.1 onFulfilled 必须是函数类型, 如果不是函数, 应该被忽略.<br> 1.2 onRejected 必须是函数类型, 如果不是函数, 应该被忽略.</p>
</li>
<li><p>onFulfilled 特性</p>
<p> 2.1 在promise变成 fulfilled 时，应该调用 onFulfilled, 参数是value<br> 2.2 在promise变成 fulfilled 之前, 不应该被调用.<br> 2.3 只能被调用一次(所以在实现的时候需要一个变量来限制执行次数)</p>
</li>
<li><p>onRejected 特性</p>
<p> 3.1 在promise变成 rejected 时，应该调用 onRejected, 参数是reason<br> 3.2 在promise变成 rejected 之前, 不应该被调用.<br> 3.3 只能被调用一次(所以在实现的时候需要一个变量来限制执行次数)</p>
</li>
<li><p>onFulfilled 和 onRejected 应该是微任务</p>
<p> 这里用queueMicrotask来实现微任务的调用.</p>
</li>
<li><p>then方法可以被调用多次</p>
<p> 5.1 promise状态变成 fulfilled 后，所有的 onFulfilled 回调都需要按照then的顺序执行, 也就是按照注册顺序执行(所以在实现的时候需要一个数组来存放多个onFulfilled的回调)<br> 5.2 promise状态变成 rejected 后，所有的 onRejected 回调都需要按照then的顺序执行, 也就是按照注册顺序执行(所以在实现的时候需要一个数组来存放多个onRejected的回调)</p>
</li>
<li><p>返回值</p>
<p> then 应该返回一个promise</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(onFulfilled, onRejected);</span><br></pre></td></tr></table></figure>

<p> 6.1 onFulfilled 或 onRejected 执行的结果为x, 调用 resolvePromise( 这里大家可能难以理解, 可以先保留疑问, 下面详细讲一下resolvePromise是什么东西 )<br> 6.2 如果 onFulfilled 或者 onRejected 执行时抛出异常e, promise2需要被reject<br> 6.3 如果 onFulfilled 不是一个函数, promise2 以promise1的value 触发fulfilled<br> 6.4 如果 onRejected 不是一个函数, promise2 以promise1的reason 触发rejected</p>
</li>
<li><p>resolvePromise</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolvePromise(promise2, x, resolve, reject)</span><br></pre></td></tr></table></figure>

<p> 7.1 如果 promise2 和 x 相等，那么 reject TypeError<br> 7.2 如果 x 是一个 promsie</p>
<pre><code>     如果x是pending态，那么promise必须要在pending,直到 x 变成 fulfilled or rejected.
     如果 x 被 fulfilled, fulfill promise with the same value.
     如果 x 被 rejected, reject promise with the same reason.
</code></pre>
<p> 7.3 如果 x 是一个 object 或者 是一个 function</p>
<pre><code> let then = x.then.
 如果 x.then 这步出错，那么 reject promise with e as the reason.
 如果 then 是一个函数，then.call(x, resolvePromiseFn, rejectPromise)
     resolvePromiseFn 的 入参是 y, 执行 resolvePromise(promise2, y, resolve, reject);
     rejectPromise 的 入参是 r, reject promise with r.
     如果 resolvePromise 和 rejectPromise 都调用了，那么第一个调用优先，后面的调用忽略。
     如果调用then抛出异常e 
         如果 resolvePromise 或 rejectPromise 已经被调用，那么忽略
         则，reject promise with e as the reason
 如果 then 不是一个function. fulfill promise with x.
</code></pre>
<p> 这段描述看起来非常的空洞乏味, 最重要的是看不懂！ 所以待会实现代码的时候, 同学们注意一下resolvePromise函数具体的实现, 结合代码来看会好很多.</p>
</li>
</ol>
<pre><code># 一步步实现一个Promise
</code></pre>
<ol>
<li><p>平常用promise的时候, 是通过new关键字来new Promise(), 所以咱们应该用构造函数或者class来实现. 都2021年了, 咱们就用class来实现一下吧.</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MPromise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义三种状态类型</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>设置初始状态</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MPromise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始状态为pending</span></span><br><span class="line">        <span class="built_in">this</span>.status = PENDING;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.reason = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>resolve 和 reject 方法</p>
<ol>
<li>根据刚才的规范, 这两个方法是要更改status的, 从pending改到fulfilled/rejected.</li>
<li>注意两个函数的入参分别是value 和 reason. </li>
</ol>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MPromise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始状态为pending</span></span><br><span class="line">        <span class="built_in">this</span>.status = PENDING;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.reason = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">            <span class="built_in">this</span>.reason = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>是不是发现咱们的promise少了入参, 咱们来加一下</p>
<ol>
<li>入参是一个函数, 函数接收resolve和reject两个参数.</li>
<li>注意在初始化promise的时候, 就要执行这个函数, 并且有任何报错都要通过reject抛出去</li>
</ol>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MPromise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始状态为pending</span></span><br><span class="line">        <span class="built_in">this</span>.status = PENDING;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.reason = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fn(<span class="built_in">this</span>.resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>.reject.bind(<span class="built_in">this</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="built_in">this</span>.reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.status = FULFILLED;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.status === PENDING) &#123;</span><br><span class="line">            <span class="built_in">this</span>.status = REJECTED;</span><br><span class="line">            <span class="built_in">this</span>.reason = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来来实现一下关键的then方法</p>
<ol>
<li>then接收两个参数, onFulfilled 和 onRejected</li>
</ol>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>检查并处理参数, 之前提到的如果不是function, 就忽略. 这个忽略指的是原样返回value或者reason.</li>
</ol>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">isFunction</span>(<span class="params">param</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> param === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fulFilledFn = <span class="built_in">this</span>.isFunction(onFulfilled) ? onFulfilled : <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> rejectedFn = <span class="built_in">this</span>.isFunction(onRejected) ? onRejected : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> reason</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>根据当前promise的状态, 调用不同的函数</li>
</ol>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fulFilledFn = <span class="built_in">this</span>.isFunction(onFulfilled) ? onFulfilled : <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> rejectedFn = <span class="built_in">this</span>.isFunction(onRejected) ? onRejected : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">            fulFilledFn(<span class="built_in">this</span>.value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">            rejectedFn(<span class="built_in">this</span>.reason);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>这个时候有的同学要问了, 你这样写, 是在then函数被调用的瞬间就会执行. 那这时候如果status还没变成fulfilled或者rejected怎么办, 很有可能还是pending的.</p>
<ol>
<li>那么我们首先要拿到所有的回调, 然后才能在某个时机去执行他. 新建两个数组, 来分别存储成功和失败的回调, 调用then的时候, 如果还是pending就存入数组.</li>
</ol>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fulFilledFn = <span class="built_in">this</span>.isFunction(onFulfilled) ? onFulfilled : <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> rejectedFn = <span class="built_in">this</span>.isFunction(onRejected) ? onRejected : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">            fulFilledFn(<span class="built_in">this</span>.value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">            rejectedFn(<span class="built_in">this</span>.reason);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> PENDING: &#123;</span><br><span class="line">            <span class="built_in">this</span>.FULFILLED_CALLBACK_LIST.push(realOnFulfilled);</span><br><span class="line">            <span class="built_in">this</span>.REJECTED_CALLBACK_LIST.push(realOnRejected);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在status发生变化的时候, 就执行所有的回调. 这里咱们用一下es6的getter和setter. 这样更符合语义, 当status改变时, 去做什么事情. (当然也可以顺序执行, 在给status赋值后, 下面再加一行forEach)</li>
</ol>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> <span class="title">status</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="title">status</span>(<span class="params">newStatus</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (newStatus) &#123;</span><br><span class="line">        <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">            <span class="built_in">this</span>.FULFILLED_CALLBACK_LIST.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                callback(<span class="built_in">this</span>.value);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">            <span class="built_in">this</span>.REJECTED_CALLBACK_LIST.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> &#123;</span><br><span class="line">                callback(<span class="built_in">this</span>.reason);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>then的返回值<br>这块内容比较多, 所以单拿出来了</p>
<p> 7.1 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e。(这样的话, 我们就需要手动catch代码，遇到报错就reject)</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fulFilledFn = <span class="built_in">this</span>.isFunction(onFulfilled) ? onFulfilled : <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> rejectedFn = <span class="built_in">this</span>.isFunction(onRejected) ? onRejected : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fulFilledFnWithCatch = <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fulFilledFn(<span class="built_in">this</span>.value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> rejectedFnWithCatch = <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rejectedFn(<span class="built_in">this</span>.reason);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MPromise(fulFilledFnWithCatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MPromise(rejectedFnWithCatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> PENDING: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.FULFILLED_CALLBACK_LIST.push(<span class="function">() =&gt;</span> fulFilledFnWithCatch(resolve, reject));</span><br><span class="line">                <span class="built_in">this</span>.REJECTED_CALLBACK_LIST.push(<span class="function">() =&gt;</span> rejectedFnWithCatch(resolve, reject));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 7.2 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fulFilledFnWithCatch = <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fulFilledFn(<span class="built_in">this</span>.value);</span><br><span class="line">            resolve(<span class="built_in">this</span>.value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p> 7.3 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因。</p>
<p> 需要注意的是，如果promise1的onRejected执行成功了，promise2应该被resolve</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rejectedFnWithCatch = <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rejectedFn(<span class="built_in">this</span>.reason);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isFunction(onRejected)) &#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 7.4 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行resolvePromise方法</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fulFilledFn = <span class="built_in">this</span>.isFunction(onFulfilled) ? onFulfilled : <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> rejectedFn = <span class="built_in">this</span>.isFunction(onRejected) ? onRejected : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fulFilledFnWithCatch = <span class="function">(<span class="params">resolve, reject, newPromise</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.isFunction(onFulfilled)) &#123;</span><br><span class="line">                resolve(<span class="built_in">this</span>.value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> x = fulFilledFn(<span class="built_in">this</span>.value);</span><br><span class="line">                <span class="built_in">this</span>.resolvePromise(newPromise, x, resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> rejectedFnWithCatch = <span class="function">(<span class="params">resolve, reject, newPromise</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">this</span>.isFunction(onRejected)) &#123;</span><br><span class="line">                reject(<span class="built_in">this</span>.reason);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> x = rejectedFn(<span class="built_in">this</span>.reason);</span><br><span class="line">                <span class="built_in">this</span>.resolvePromise(newPromise, x, resolve, reject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">            <span class="keyword">const</span> newPromise = <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> fulFilledFnWithCatch(resolve, reject, newPromise));</span><br><span class="line">            <span class="keyword">return</span> newPromise;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">            <span class="keyword">const</span> newPromise = <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> rejectedFnWithCatch(resolve, reject, newPromise));</span><br><span class="line">            <span class="keyword">return</span> newPromise;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> PENDING: &#123;</span><br><span class="line">            <span class="keyword">const</span> newPromise = <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.FULFILLED_CALLBACK_LIST.push(<span class="function">() =&gt;</span> fulFilledFnWithCatch(resolve, reject, newPromise));</span><br><span class="line">                <span class="built_in">this</span>.REJECTED_CALLBACK_LIST.push(<span class="function">() =&gt;</span> rejectedFnWithCatch(resolve, reject, newPromise));</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> newPromise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>resolvePromise</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">resolvePromise</span>(<span class="params">newPromise, x, resolve, reject</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 newPromise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 newPromise</span></span><br><span class="line">    <span class="comment">// 这是为了防止死循环</span></span><br><span class="line">    <span class="keyword">if</span> (newPromise === x) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;The promise and the return value are the same&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MPromise) &#123;</span><br><span class="line">        <span class="comment">// 如果 x 为 Promise ，则使 newPromise 接受 x 的状态</span></span><br><span class="line">        <span class="comment">// 也就是继续执行x，如果执行的时候拿到一个y，还要继续解析y</span></span><br><span class="line">        <span class="comment">// 这个if跟下面判断then然后拿到执行其实重复了，可有可无</span></span><br><span class="line">        x.then(<span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">            resolvePromise(newPromise, y, resolve, reject);</span><br><span class="line">        &#125;, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> || <span class="built_in">this</span>.isFunction(x)) &#123;</span><br><span class="line">        <span class="comment">// 如果 x 为对象或者函数</span></span><br><span class="line">        <span class="comment">// 这个坑是跑测试的时候发现的，如果x是null，应该直接resolve</span></span><br><span class="line">        <span class="keyword">if</span> (x === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> then = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 把 x.then 赋值给 then </span></span><br><span class="line">            then = x.then;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="comment">// 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 promise</span></span><br><span class="line">            <span class="keyword">return</span> reject(error);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 then 是函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.isFunction(then)) &#123;</span><br><span class="line">            <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 将 x 作为函数的作用域 this 调用之</span></span><br><span class="line">            <span class="comment">// 传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise</span></span><br><span class="line">            <span class="comment">// 名字重名了，我直接用匿名函数了</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                then.call(</span><br><span class="line">                    x,</span><br><span class="line">                    <span class="comment">// 如果 resolvePromise 以值 y 为参数被调用，则运行 resolvePromise</span></span><br><span class="line">                    (y) =&gt; &#123;</span><br><span class="line">                        <span class="comment">// 如果 resolvePromise 和 rejectPromise 均被调用，</span></span><br><span class="line">                        <span class="comment">// 或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</span></span><br><span class="line">                        <span class="comment">// 实现这条需要前面加一个变量called</span></span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        resolvePromise(promise, y, resolve, reject);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// 如果 rejectPromise 以据因 r 为参数被调用，则以据因 r 拒绝 promise</span></span><br><span class="line">                    (r) =&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">                        called = <span class="literal">true</span>;</span><br><span class="line">                        reject(r);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="comment">// 如果调用 then 方法抛出了异常 e：</span></span><br><span class="line">                <span class="comment">// 如果 resolvePromise 或 rejectPromise 已经被调用，则忽略之</span></span><br><span class="line">                <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 否则以 e 为据因拒绝 promise</span></span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 then 不是函数，以 x 为参数执行 promise</span></span><br><span class="line">            resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 x 不为对象或者函数，以 x 为参数执行 promise</span></span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>onFulfilled 和 onRejected 是微任务</p>
<p> 咱们可以用queueMicrotask包裹执行函数</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fulFilledFn = <span class="built_in">this</span>.isFunction(onFulfilled) ? onFulfilled : <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> rejectedFn = <span class="built_in">this</span>.isFunction(onRejected) ? onRejected : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> reason;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fulFilledFnWithCatch = <span class="function">(<span class="params">resolve, reject, newPromise</span>) =&gt;</span> &#123;</span><br><span class="line">        queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">this</span>.isFunction(onFulfilled)) &#123;</span><br><span class="line">                    resolve(<span class="built_in">this</span>.value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> x = fulFilledFn(<span class="built_in">this</span>.value);</span><br><span class="line">                    <span class="built_in">this</span>.resolvePromise(newPromise, x, resolve, reject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                reject(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> rejectedFnWithCatch = <span class="function">(<span class="params">resolve, reject, newPromise</span>) =&gt;</span> &#123;</span><br><span class="line">        queueMicrotask(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">this</span>.isFunction(onRejected)) &#123;</span><br><span class="line">                    reject(<span class="built_in">this</span>.reason);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> x = rejectedFn(<span class="built_in">this</span>.reason);</span><br><span class="line">                    <span class="built_in">this</span>.resolvePromise(newPromise, x, resolve, reject);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">this</span>.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> FULFILLED: &#123;</span><br><span class="line">            <span class="keyword">const</span> newPromise = <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> fulFilledFnWithCatch(resolve, reject, newPromise));</span><br><span class="line">            <span class="keyword">return</span> newPromise;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> REJECTED: &#123;</span><br><span class="line">            <span class="keyword">const</span> newPromise = <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> rejectedFnWithCatch(resolve, reject, newPromise));</span><br><span class="line">            <span class="keyword">return</span> newPromise;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> PENDING: &#123;</span><br><span class="line">            <span class="keyword">const</span> newPromise = <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.FULFILLED_CALLBACK_LIST.push(<span class="function">() =&gt;</span> fulFilledFnWithCatch(resolve, reject, newPromise));</span><br><span class="line">                <span class="built_in">this</span>.REJECTED_CALLBACK_LIST.push(<span class="function">() =&gt;</span> rejectedFnWithCatch(resolve, reject, newPromise));</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> newPromise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>简单写点代码测试一下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">111</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;).then(<span class="built_in">console</span>.log);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(test);</span><br><span class="line"></span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

<p>这个时候同学们会发现, 为什么我可以调用.then, 不可以调用.catch呢? 因为我们并没有在类里面声明catch方法</p>
</li>
<li><p>catch方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>promise.resolve</p>
<p>将现有对象转为Promise对象，如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为fulfilled。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">param</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (param <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        resolve(param);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>promise.reject</p>
<p>返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>promise.race</p>
<p><code>const p = Promise.race([p1, p2, p3]);</code></p>
<p>该方法是将多个 Promise 实例，包装成一个新的 Promise 实例。<br>只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseList</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> length = promiseList.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolve();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                MPromise.resolve(promiseList[i]).then(</span><br><span class="line">                    (value) =&gt; &#123;</span><br><span class="line">                        <span class="keyword">return</span> resolve(value);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    (reason) =&gt; &#123;</span><br><span class="line">                        <span class="keyword">return</span> reject(reason);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写段测试代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">111</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test2 = <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">222</span>);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test3 = <span class="keyword">new</span> MPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">333</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MPromise.race([test, test2, test3]).then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/15/Promise%E8%A7%84%E8%8C%83%E5%8F%8A%E5%BA%94%E7%94%A8/" data-id="cknj115pg0000hmcu8f6d4fa8" data-title="Promise规范及应用" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/04/15/Typescript%E5%85%A5%E9%97%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Typescript入门</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/15/Promise%E8%A7%84%E8%8C%83%E5%8F%8A%E5%BA%94%E7%94%A8/">Promise规范及应用</a>
          </li>
        
          <li>
            <a href="/2021/04/15/Typescript%E5%85%A5%E9%97%A8/">Typescript入门</a>
          </li>
        
          <li>
            <a href="/2021/04/15/hello-world/">Hexo建站</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Micheal Yang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>